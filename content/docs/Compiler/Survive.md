# [](.md)
- [ ] Definition of compiler vs interpreter
- [ ] Phases of a compiler (with diagram)
    - [ ] Lexical analysis
    - [ ] Syntax analysis
    - [ ] Semantic analysis
    - [ ] Intermediate code generation
    - [ ] Code optimization
    - [ ] Code generation
- [ ] Lexical analyzer
    - [ ] Tokens, lexemes, patterns
    - [ ] Role of lexical analyzer
    - [ ] Input buffering
- [ ] Regular expressions
- [ ] NFA vs DFA
- [ ] NFA → DFA (basic idea, not full construction)
- [ ] RE → NFA (Thompson’s construction – idea level)

# [](.md)
- [ ] Top-down vs Bottom-up parsing (table comparison)
- [ ] Context Free Grammar (CFG)
- [ ] Derivation vs parse tree
- [ ] Ambiguity, precedence, associativity
- [ ] Recursive descent parsing (idea)
- [ ] LL(1) grammar (definition + conditions + predictive parsing table)
- [ ] Shift-reduce parsing (idea + conflicts)
- [ ] Operator precedence parsing

# [](.md)
- [ ] Syntax Directed Translation (Definitions)
- [ ] S-Attributed vs L-Attributed definitions
- [ ] Symbol table (what it stores, why it exists)
- [ ] Type checking (static vs dynamic)
- [ ] Intermediate code:
    - [ ] Three-address code
    - [ ] Quadruples, Triples, Indirect triples
    - [ ] DAG 

# [](.md)
- [ ] Activation record (diagram!)
- [ ] Stack allocation vs heap allocation
- [ ] Static vs dynamic allocation
- [ ] Issues with nested procedures
- [ ] Runtime environment overview

# [](.md)
- [ ] What is code generation
- [ ] Basic blocks and flow graphs
- [ ] Data flow analysis (definition + examples)
- [ ] Reaching definitions
- [ ] Live variable analysis
- [ ] Available expressions

